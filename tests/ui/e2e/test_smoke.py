"""
Full smoke test: Setup from scratch, transfer a torrent, verify in UI.

This test simulates a new user setting up Transferarr from scratch:
1. Delete all existing clients and connections
2. Add source and target download clients via UI
3. Add a connection between them via UI  
4. Create a torrent, add to Radarr
5. Verify transfer completes and torrent appears on target in UI

This is a comprehensive test that validates the entire user workflow.
"""
import pytest
from playwright.sync_api import Page, expect

from tests.utils import (
    movie_catalog,
    make_torrent_name,
    wait_for_queue_item_by_hash,
    wait_for_torrent_in_deluge,
    wait_for_transferarr_state,
)
from tests.ui.helpers import (
    UI_TIMEOUTS,
    TRANSFERARR_BASE_URL,
    add_connection_via_ui,
    delete_connection_via_api,
    log_test_step,
)


class TestE2EFullSmokeTest:
    """
    Full smoke test: Setup from scratch, transfer a torrent, verify in UI.
    
    This test simulates a new user setting up Transferarr from scratch:
    1. Delete all existing clients and connections
    2. Add source and target download clients via UI
    3. Add a connection between them via UI  
    4. Create a torrent, add to Radarr
    5. Verify transfer completes and torrent appears on target in UI
    
    This is a comprehensive test that validates the entire user workflow.
    """
    
    @pytest.fixture(autouse=True)
    def setup(self, clean_test_environment, transferarr):
        """Setup clean environment with running transferarr."""
        transferarr.start(wait_healthy=True)
        self.transferarr = transferarr
    
    def _load_reference_config(self) -> dict:
        """
        Load the reference configuration for the test environment.
        
        Reads the generated config from /transferarr-config/config.json
        (mounted from shared-config volume, generated by service-registrar).
        
        This ensures the smoke test uses the exact same config that transferarr
        normally uses, avoiding path/hostname mismatches.
        """
        import json
        from pathlib import Path
        
        # Read from mounted volume (generated by service-registrar)
        config_path = Path('/transferarr-config/config.json')
        
        with open(config_path) as f:
            return json.load(f)
    
    def _delete_all_clients_and_connections(self, page: Page):
        """Delete all existing clients and connections via API."""
        import requests
        
        log_test_step("Cleanup: Delete all existing connections")
        # Get all connections
        response = requests.get(f"{TRANSFERARR_BASE_URL}/api/v1/connections", timeout=10)
        if response.status_code == 200:
            connections_response = response.json()
            # Unwrap data envelope (supports both old and new format)
            connections = connections_response.get('data', connections_response) if isinstance(connections_response, dict) and 'data' in connections_response else connections_response
            # Delete connections by name (URL-encoded)
            from urllib.parse import quote
            for conn in connections:
                encoded_name = quote(conn['name'], safe='')
                delete_resp = requests.delete(
                    f"{TRANSFERARR_BASE_URL}/api/v1/connections/{encoded_name}", 
                    timeout=10
                )
                print(f"  Deleted connection '{conn['name']}': {delete_resp.status_code}")
        
        log_test_step("Cleanup: Delete all existing clients")
        # Get all clients
        response = requests.get(f"{TRANSFERARR_BASE_URL}/api/v1/download_clients", timeout=10)
        if response.status_code == 200:
            clients_response = response.json()
            # Unwrap data envelope (supports both old and new format)
            clients = clients_response.get('data', clients_response) if isinstance(clients_response, dict) and 'data' in clients_response else clients_response
            for client_name in clients.keys():
                delete_resp = requests.delete(
                    f"{TRANSFERARR_BASE_URL}/api/v1/download_clients/{client_name}",
                    timeout=10
                )
                print(f"  Deleted client {client_name}: {delete_resp.status_code}")
    
    def _add_client_via_ui(
        self, 
        settings_page, 
        page: Page,
        name: str,
        host: str,
        port: int,
        username: str,
        password: str,
        connection_type: str = "rpc"
    ):
        """Add a download client via the UI."""
        settings_page.open_add_client_modal()
        settings_page.fill_client_form(
            name=name,
            host=host,
            port=port,
            password=password,
            username=username,
            connection_type=connection_type
        )
        
        # Test connection
        with page.expect_response(
            lambda r: "/api/v1/download_clients/test" in r.url,
            timeout=UI_TIMEOUTS['api_response']
        ) as response_info:
            settings_page.test_client_connection()
        
        test_response = response_info.value.json()
        # Unwrap data envelope (supports both old and new format)
        test_result = test_response.get('data', test_response) if isinstance(test_response, dict) and 'data' in test_response else test_response
        assert test_result.get("success"), f"Connection test failed for {name}: {test_response}"
        
        # Save
        save_btn = settings_page.page.locator(settings_page.SAVE_CLIENT_BTN)
        expect(save_btn).to_be_enabled(timeout=UI_TIMEOUTS['element_visible'])
        
        with page.expect_response(
            lambda r: "/api/v1/download_clients" in r.url and r.request.method == "POST",
            timeout=UI_TIMEOUTS['api_response']
        ):
            settings_page.save_client()
        
        expect(settings_page.page.locator(settings_page.CLIENT_MODAL)).not_to_be_visible()
        settings_page.wait_for_clients_loaded()
        print(f"  Added client: {name}")
    
    @pytest.mark.timeout(600)  # 10 minutes for this comprehensive test
    def test_full_setup_and_transfer_workflow(
        self,
        settings_page,
        torrents_page,
        dashboard_page,
        page: Page,
        create_torrent,
        radarr_client,
        deluge_source,
        deluge_target,
    ):
        """
        Full smoke test: Setup from scratch, transfer a torrent, verify in UI.
        
        This comprehensive test validates the entire new-user experience:
        1. Start with empty config (delete all clients/connections)
        2. Add source and target clients via UI
        3. Add connection between them via UI
        4. Create torrent, add movie to Radarr
        5. Wait for transfer to complete
        6. Verify torrent appears on target client in Torrents page
        """
        # Load reference config for test data
        config = self._load_reference_config()
        source_config = config['download_clients']['source-deluge']
        target_config = config['download_clients']['target-deluge']
        # Connections is a dict keyed by name, get first connection config
        connection_config = list(config['connections'].values())[0]
        
        # ========== Phase 1: Clean slate ==========
        log_test_step("Phase 1: Clean slate - delete all existing config")
        self._delete_all_clients_and_connections(page)
        
        # Restart transferarr to pick up empty config
        self.transferarr.restart()
        page.wait_for_timeout(2000)  # Wait for restart
        
        # ========== Phase 2: Add clients via UI ==========
        log_test_step("Phase 2: Add download clients via UI")
        settings_page.goto()
        settings_page.wait_for_clients_loaded()
        
        # Verify we start with 0 clients
        initial_count = settings_page.get_client_count()
        print(f"  Initial client count: {initial_count}")
        assert initial_count == 0, f"Expected 0 clients after cleanup, got {initial_count}"
        
        # Add source client
        log_test_step("Phase 2a: Add source client")
        self._add_client_via_ui(
            settings_page, page,
            name="source-deluge",
            host=source_config['host'],
            port=source_config['port'],
            username=source_config['username'],
            password=source_config['password'],
            connection_type=source_config['connection_type']
        )
        
        # Add target client
        log_test_step("Phase 2b: Add target client")
        self._add_client_via_ui(
            settings_page, page,
            name="target-deluge",
            host=target_config['host'],
            port=target_config['port'],
            username=target_config['username'],
            password=target_config['password'],
            connection_type=target_config['connection_type']
        )
        
        # Verify 2 clients now exist
        assert settings_page.get_client_count() == 2, "Should have 2 clients"
        print("  ✓ Both clients added successfully")
        
        # ========== Phase 3: Add connection via UI ==========
        log_test_step("Phase 3: Add connection via UI")
        
        add_connection_via_ui(
            settings_page, page,
            connection_name="source-deluge -> target-deluge",
            from_client="source-deluge",
            to_client="target-deluge",
            from_config=connection_config['transfer_config']['from'],
            to_config=connection_config['transfer_config']['to'],
            paths={
                'source_dot_torrent_path': connection_config['source_dot_torrent_path'],
                'source_torrent_download_path': connection_config['source_torrent_download_path'],
                'destination_dot_torrent_tmp_dir': connection_config['destination_dot_torrent_tmp_dir'],
                'destination_torrent_download_path': connection_config['destination_torrent_download_path'],
            }
        )
        print("  ✓ Connection added successfully")
        
        # Restart transferarr to initialize the new connection
        log_test_step("Phase 3b: Restart transferarr to initialize connection")
        self.transferarr.restart()
        page.wait_for_timeout(3000)  # Wait for restart and initialization
        
        # ========== Phase 4: Create and transfer torrent ==========
        log_test_step("Phase 4: Create torrent and trigger transfer")
        movie = movie_catalog.get_movie()
        torrent_name = make_torrent_name(movie['title'], movie['year'])
        torrent_info = create_torrent(torrent_name, size_mb=10)
        print(f"  Created torrent: {torrent_name}")
        print(f"  Hash: {torrent_info['hash']}")
        
        # Add movie to Radarr
        radarr_client.add_movie(
            title=movie['title'],
            tmdb_id=movie['tmdb_id'],
            year=movie['year'],
            search=True
        )
        
        # Wait for Radarr to grab
        log_test_step("Phase 4a: Wait for Radarr to grab torrent")
        wait_for_queue_item_by_hash(
            radarr_client, 
            torrent_info['hash'], 
            timeout=60, 
            expected_status='completed'
        )
        print("  Torrent grabbed by Radarr")
        
        # Wait for seeding on source
        log_test_step("Phase 4b: Wait for seeding on source")
        wait_for_torrent_in_deluge(
            deluge_source,
            torrent_info['hash'],
            timeout=60,
            expected_state='Seeding'
        )
        print("  Torrent seeding on source")
        
        # Wait for transferarr to track it
        log_test_step("Phase 4c: Wait for transferarr to track torrent")
        wait_for_transferarr_state(
            self.transferarr,
            torrent_name,
            expected_state='HOME_SEEDING',
            timeout=60
        )
        print("  Transferarr tracking torrent")
        
        # ========== Phase 5: Wait for transfer and verify ==========
        log_test_step("Phase 5: Wait for transfer to complete")
        wait_for_transferarr_state(
            self.transferarr,
            torrent_name,
            expected_state='TARGET_SEEDING',
            timeout=180
        )
        print("  Transfer complete - torrent on target!")
        
        # ========== Phase 6: Verify in UI ==========
        log_test_step("Phase 6: Verify torrent appears on target in UI")
        
        # Check dashboard first
        dashboard_page.goto()
        dashboard_page.wait_for_stats_update()
        stats = dashboard_page.get_all_stats()
        print(f"  Dashboard stats: {stats}")
        
        # Navigate to torrents page
        torrents_page.goto()
        torrents_page.wait_for_torrents_loaded()
        
        # Verify we have client tabs
        tab_names = torrents_page.get_client_tab_names()
        print(f"  Client tabs: {tab_names}")
        assert len(tab_names) >= 2, f"Expected at least 2 client tabs, got {tab_names}"
        
        # Find and switch to target tab
        target_tab_found = False
        for tab_name in tab_names:
            if 'target' in tab_name.lower():
                torrents_page.switch_to_client_tab(tab_name)
                target_tab_found = True
                break
        
        assert target_tab_found, f"Could not find target client tab in {tab_names}"
        
        # Verify via API that torrent is on target
        with page.expect_response(
            lambda r: "/api/v1/all_torrents" in r.url,
            timeout=UI_TIMEOUTS['api_response']
        ) as response_info:
            page.reload()
        
        all_torrents_response = response_info.value.json()
        # Unwrap data envelope (supports both old and new format)
        all_torrents = all_torrents_response.get('data', all_torrents_response) if isinstance(all_torrents_response, dict) and 'data' in all_torrents_response else all_torrents_response
        
        # Find torrent on target client
        found_on_target = False
        for client_name, client_torrents in all_torrents.items():
            if 'target' in client_name.lower():
                for torrent_hash, torrent_data in client_torrents.items():
                    name = torrent_data.get('name', '') if isinstance(torrent_data, dict) else ''
                    if torrent_name in name:
                        found_on_target = True
                        print(f"  ✓ Found torrent on target client: {client_name}")
                        break
        
        assert found_on_target, f"Torrent {torrent_name} not found on target client!"
        
        print("\n" + "="*60)
        print("✅ FULL SMOKE TEST PASSED!")
        print("="*60)
        print("Successfully completed:")
        print("  1. Deleted all existing config")
        print("  2. Added source-deluge client via UI")
        print("  3. Added target-deluge client via UI")
        print("  4. Added connection with SFTP config via UI")
        print("  5. Created torrent and added movie to Radarr")
        print("  6. Waited for transfer to complete")
        print("  7. Verified torrent appears on target in UI")
        print("="*60)
